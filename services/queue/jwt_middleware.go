package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"
)

// AuthPayload represents the JWT claims
type AuthPayload struct {
	ID    string   `json:"id"`
	Email string   `json:"email"`
	Name  string   `json:"name,omitempty"`
	Role  string   `json:"role,omitempty"`
	Roles []string `json:"roles,omitempty"`
	Exp   int64    `json:"exp,omitempty"`
	Iss   string   `json:"iss,omitempty"`
	Aud   string   `json:"aud,omitempty"`
}

// DecodeJWTPayload decodes JWT without verification
// Note: This is acceptable since tokens are generated by our trusted auth service
// and we're behind Nginx which provides additional security
func DecodeJWTPayload(tokenString string) (*AuthPayload, error) {
	parts := strings.Split(tokenString, ".")
	if len(parts) != 3 {
		return nil, errors.New("invalid token format")
	}

	// Decode the payload (second part)
	payload := parts[1]
	
	// Add padding if needed for base64 decoding
	padding := 4 - len(payload)%4
	if padding != 4 {
		payload += strings.Repeat("=", padding)
	}

	decoded, err := base64.URLEncoding.DecodeString(payload)
	if err != nil {
		// Try with RawURLEncoding
		decoded, err = base64.RawURLEncoding.DecodeString(parts[1])
		if err != nil {
			return nil, fmt.Errorf("failed to decode payload: %w", err)
		}
	}

	var claims AuthPayload
	if err := json.Unmarshal(decoded, &claims); err != nil {
		return nil, fmt.Errorf("failed to unmarshal claims: %w", err)
	}

	// Check expiration
	if claims.Exp > 0 {
		now := time.Now().Unix()
		if claims.Exp < now {
			return nil, errors.New("token expired")
		}
	}

	return &claims, nil
}

// ExtractBearerToken extracts the token from Authorization header
func ExtractBearerToken(authHeader string) (string, error) {
	if authHeader == "" {
		return "", errors.New("authorization header missing")
	}

	parts := strings.SplitN(authHeader, " ", 2)
	if len(parts) != 2 || parts[0] != "Bearer" {
		return "", errors.New("invalid authorization format. Expected: Bearer <token>")
	}

	return parts[1], nil
}

// VerifyToken verifies a JWT token by decoding it
func VerifyToken(tokenString string) (*AuthPayload, error) {
	return DecodeJWTPayload(tokenString)
}

// GetUserFromContext retrieves user info from request context
func GetUserFromContext(ctx context.Context) (*AuthPayload, bool) {
	user, ok := ctx.Value("user").(*AuthPayload)
	return user, ok
}
